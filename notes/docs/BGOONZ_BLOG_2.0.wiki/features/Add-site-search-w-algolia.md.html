<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Add-site-search-w-algolia.md</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="adding-a-site-search-to-your-stackbit-gatsby-site">Adding a Site Search to Your Stackbit Gatsby Site</h1>
<p>There are a number of options for adding search to your Stackbit site built with Gatsby. There are some free options like <a href="https://lunrjs.com/">Lunr</a> that are free and open source and can perform simple searches on pre-generated indexes. In this example, we’ll use a service called <a href="https://www.algolia.com/">Algolia</a> for the search API. Algolia is a service specifically geared towards search and thus has many more features. Algolia is a commercial offering, but it has a generous free tier.</p>
<p>The example below was built with Stackbit. You can see the full project code at <a href="https://github.com/remotesynth/good-celery" class="uri">https://github.com/remotesynth/good-celery</a>).</p>
<h2 id="setting-up-algolia"><a href="https://www.stackbit.com/docs/developer-guides/gatsby/site-search/#setting_up_algolia"></a>Setting Up Algolia</h2>
<p>You’ll need to set up your account on Algolia and set up a project. You can skip the steps about setting up indices when creating your account - we’ll take care of that via code. However, be sure to grab all your API keys from the Algolia dashboard as we’ll need them later.</p>
<p>Algolia provides two projects that we’ll make use of:</p>
<ul>
<li><a href="https://github.com/algolia/gatsby-plugin-algolia">Gatsby Plugin Algolia</a> will help us create our indices and make sure they are kept in sync with our content.</li>
<li><a href="https://github.com/algolia/react-instantsearch">React InstantSearch</a> provides a pre-built set of tools for interacting with Algolia’s search API for a "search as you type” UI. This project also encompasses the <code>react-instantsearch-dom</code> UI tools we’ll also use.</li>
</ul>
<p>Let’s start by installing these on our Gatsby project.</p>
<pre><code>npm install gatsby-plugin-algolia react-instantsearch react-instantsearch-dom --save
</code></pre>
<p>Copy</p>
<h3 id="configuring-algolia-in-our-gatsby-project"><a href="https://www.stackbit.com/docs/developer-guides/gatsby/site-search/#configuring_algolia_in_our_gatsby_project"></a>Configuring Algolia in Our Gatsby Project</h3>
<p>Next we need to edit our <code>gatsby-config.js</code> file, first by adding these two lines prior to the <code>module.exports</code> block.</p>
<pre><code>const queries = require(&#39;./src/utils/algolia&#39;);
require(&#39;dotenv&#39;).config();
</code></pre>
<p>Copy</p>
<p>Neither of these files exist yet, but we’ll create them in a moment. Staying in <code>gatsby-config.js</code>, within the <code>module.exports</code> block and within the <code>plugins</code> array, add the following details:</p>
<pre><code>{
  resolve: `gatsby-plugin-algolia`,
  options: {
    appId: process.env.GATSBY_ALGOLIA_APP_ID,
    apiKey: process.env.ALGOLIA_ADMIN_KEY,
    queries,
    chunkSize: 10000,
  },
}
</code></pre>
<p>Finally, create (or open) a <code>.env</code> file and add the API key details from Algolia to the file as follow (replacing the values on the right of the equal signs with the appropriate keys from Algolia)</p>
<pre><code>GATSBY_ALGOLIA_APP_ID=MY_ALGOLIA_APP_ID
GATSBY_ALGOLIA_SEARCH_KEY=MY_ALGOLIA_SEARCH_KEY
GATSBY_ALGOLIA_ADMIN_KEY=MY_ALGOLIA_ADMIN_KEY
</code></pre>
<p>Please ensure that this <code>.env</code> file is added to your <code>.gitignore</code> so that you do not accidentally check in your private keys.</p>
<h3 id="adding-slugs-to-posts"><a href="https://www.stackbit.com/docs/developer-guides/gatsby/site-search/#adding_slugs_to_posts"></a>Adding Slugs to Posts</h3>
<p>In some cases, pages do not have a <code>slug</code> field in the frontmatter. Having slugs available in the search makes it much easier to output the results. Rather than manually add slugs to all of the content, Gatsby provides instructions on how to <a href="https://www.gatsbyjs.org/docs/creating-slugs-for-pages/">create slugs for pages</a> automatically.</p>
<p>This depends on <code>gatsby-source-filesystem</code>, so we’ll need to install that first. Then, add the following code to <code>gatsby-node.js</code>:</p>
<pre><code>const { createFilePath } = require(`gatsby-source-filesystem`);

exports.onCreateNode = ({ node, getNode, actions }) =&gt; {
  const { createNodeField } = actions;
  if (node.internal.type === `MarkdownRemark`) {
    const slug = createFilePath({ node, getNode, basePath: `pages` });
    createNodeField({
      node,
      name: `slug`,
      value: slug
    });
  }
};
</code></pre>
<p>Copy</p>
<p>Now when we query Gastby for our pages, we’ll be able to get the slug and provide that to our Algolia search index.</p>
<h3 id="populating-our-indices"><a href="https://www.stackbit.com/docs/developer-guides/gatsby/site-search/#populating_our_indices"></a>Populating Our Indices</h3>
<p>Let’s create the queries that will populate our indices on Algolia. It’s important to note that your query depends on the data you have in your content and how you store your content. The best way to create and test your GraphQL queries to be sure you will populate your indices correctly is to use GraphiQL, which is running locally whenever you run <code>gatsby develop</code> generally at <code>http://localhost:8000/___graphql</code>.</p>
<p>Typically a Stackbit site has both pages and posts that have differing front matter properties. For this example, we’ll be creating a blog search so we’ll create an index that is specific to the blog called <code>Posts</code>. Feel free to customize the query to create indices for whatever content you wish to make searchable.</p>
<p>Place the query in a <code>/src/utils/algolia.js</code> file like the one below (recall that we referenced this file in our <code>gatsby-config.js</code> file above). Note that the excerpts for the content are truncated to prevent going over the character limit for individual Algolia records.</p>
<pre><code>const postQuery = `{
  posts: allMarkdownRemark(
    filter: { fileAbsolutePath: { regex: &quot;/posts/&quot; } }
  ) {
    edges {
      node {
        objectID: id
        frontmatter {
          title
          date(formatString: &quot;MMM D, YYYY&quot;)
          subtitle
          description: excerpt
          thumb_image
        }
        fields {
          slug
        }
        excerpt(pruneLength: 5000)
      }
    }
  }
}`;

const flatten = (arr) =&gt;
  arr.map(({ node: { frontmatter, ...rest } }) =&gt; ({
    ...frontmatter,
    ...rest
  }));
const settings = { attributesToSnippet: [`excerpt:20`] };

const queries = [
  {
    query: postQuery,
    transformer: ({ data }) =&gt; flatten(data.posts.edges),
    indexName: `Posts`,
    settings
  }
];

module.exports = queries;
</code></pre>
<p>Copy</p>
<p>With the queries in place, our indices on Algolia will update whenever we build our Gatsby site. To do this, run <code>gatsby build</code> from the command line to run a production build of the site. We should see an indication that our indices have been populated from the console output.</p>
<figure>
<img src="https://www.stackbit.com/docs/images/indices-populated-sm.png" alt="console showing indices have been populated" /><figcaption>console showing indices have been populated</figcaption>
</figure>
<p>We can now see the results when going into Algolia and browsing Indices.</p>
<figure>
<img src="https://www.stackbit.com/docs/images/algolia-indices-sm.png" alt="indices populated on Algolia dashboard" /><figcaption>indices populated on Algolia dashboard</figcaption>
</figure>
<h2 id="creating-the-search-ui"><a href="https://www.stackbit.com/docs/developer-guides/gatsby/site-search/#creating_the_search_ui"></a>Creating the Search UI</h2>
<p>Now that our search indices are populated, let’s display some results. To do this, we’re going to use <a href="https://github.com/algolia/react-instantsearch">React InstantSearch</a>, which offers a search-as-you-type experience. It pretty much works out of the box using the <a href="https://www.algolia.com/doc/guides/building-search-ui/installation/react/">code they provide</a>.</p>
<p>Let’s look at the most basic implementation in action. Start by creating a new template as <code>/src/templates/search.js</code>. This template will just wrap the example code taken almost directly from the InstantSearch page and place it in the site’s UI so that we can try it out.</p>
<pre><code>import React from &#39;react&#39;;
import algoliasearch from &#39;algoliasearch/lite&#39;;
import { InstantSearch, SearchBox, Hits } from &#39;react-instantsearch-dom&#39;;
import { Layout } from &#39;../components/index&#39;;

const searchClient = algoliasearch(process.env.GATSBY_ALGOLIA_APP_ID, process.env.GATSBY_ALGOLIA_SEARCH_KEY);

export default class Search extends React.Component {
  render() {
    return (
      &lt;Layout {...this.props}&gt;
        &lt;div className=&quot;outer&quot;&gt;
          &lt;div className=&quot;inner&quot;&gt;
            &lt;InstantSearch searchClient={searchClient} indexName=&quot;Posts&quot;&gt;
              &lt;SearchBox /&gt;
              &lt;Hits /&gt;
            &lt;/InstantSearch&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/Layout&gt;
    );
  }
}
</code></pre>
<p>Copy</p>
<p>We initialize the search client with the secrets that are in the <code>.env</code> file we created earlier. Within the layout elements, we include the <code>InstantSearch</code> element tied to our <code>Posts</code> index in Algolia. The <code>SearchBox</code> outputs a search input UI and <code>hits</code> outputs the results. Next, just create a search page that will utilize this layout at <code>/src/pages/blog/search.md</code>.</p>
<pre><code>---
title: Search the Blog
template: search
---
</code></pre>
<p>Copy</p>
<p>From the console run <code>gatsby develop</code> and then navigate to the page, which is typically available at <code>http://localhost:8000/blog/search/</code>. Here’s what you should see:</p>
<figure>
<img src="https://www.stackbit.com/docs/images/basic-instantsearch.gif" alt="InstantSearch unstyled" /><figcaption>InstantSearch unstyled</figcaption>
</figure>
<h3 id="customizing-the-output"><a href="https://www.stackbit.com/docs/developer-guides/gatsby/site-search/#customizing_the_output"></a>Customizing the Output</h3>
<p>Let’s integrate the search into our existing blog page, allowing a user to filter the results based upon their search. In doing so, we’ll see how to customize the output of the InstantSearch <code>Hits</code> component.</p>
<p>Create a new component as <code>src/components/search.js</code> using the source below. Don’t worry, I’ll explain what we’re doing in a moment.</p>
<pre><code>import React from &#39;react&#39;;
import algoliasearch from &#39;algoliasearch/lite&#39;;
import { connectHits, InstantSearch, SearchBox } from &#39;react-instantsearch-dom&#39;;
import { Link, safePrefix } from &#39;../utils&#39;;
import moment from &#39;moment-strftime&#39;;

const Hits = connectHits(({ hits }) =&gt; (
  &lt;div&gt;
    {hits.length ? (
      &lt;div className=&quot;post-feed&quot;&gt;
        {hits.map((hit) =&gt; {
          return (
            &lt;article key={hit.objectID} className=&quot;post post-card&quot;&gt;
              &lt;div className=&quot;post-card-inside&quot;&gt;
                &lt;Link className=&quot;post-card-thumbnail&quot; to={safePrefix(hit.fields.slug)}&gt;
                  &lt;img className=&quot;thumbnail&quot; src={safePrefix(hit.thumb_image)} alt={hit.title} /&gt;
                &lt;/Link&gt;
                &lt;div className=&quot;post-card-content&quot;&gt;
                  &lt;header className=&quot;post-header&quot;&gt;
                    &lt;h2 className=&quot;post-title&quot;&gt;
                      &lt;Link to={safePrefix(hit.fields.slug)} rel=&quot;bookmark&quot;&gt;
                        {hit.title}
                      &lt;/Link&gt;
                    &lt;/h2&gt;
                  &lt;/header&gt;
                  &lt;div className=&quot;post-excerpt&quot;&gt;
                    &lt;p&gt;{hit.description}&lt;/p&gt;
                  &lt;/div&gt;
                  &lt;footer className=&quot;post-meta&quot;&gt;
                    &lt;time className=&quot;published&quot; dateTime={moment(hit.date).strftime(&#39;%Y-%m-%d %H:%M&#39;)}&gt;
                      {moment(hit.date).strftime(&#39;%B %d, %Y&#39;)}
                    &lt;/time&gt;
                  &lt;/footer&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/article&gt;
          );
        })}
      &lt;/div&gt;
    ) : (
      &lt;p&gt;There were no results for your query. Please try again.&lt;/p&gt;
    )}
  &lt;/div&gt;
));

export default function Search({ indexName }) {
  const searchClient = algoliasearch(process.env.GATSBY_ALGOLIA_APP_ID, process.env.GATSBY_ALGOLIA_SEARCH_KEY);
  return (
    &lt;InstantSearch indexName={indexName} searchClient={searchClient}&gt;
      &lt;SearchBox /&gt;
      &lt;Hits /&gt;
    &lt;/InstantSearch&gt;
  );
}
</code></pre>
<p>Copy</p>
<p>As you can see, the actual component output UI is almost identical to the prior search page, with just a <code>SearchBox</code> and <code>Hits</code>. However, prior to that, we are overriding the default output behavior of <code>Hits</code>. If the results return any records, we loop through them, outputting cards identical to the existing blog list on <code>src/templates/blog.js</code>, using the <code>hit</code> (i.e. search result) values to populate the output. If there are no results, we just display some text informing the user.</p>
<p>Now let’s add it to our blog. Keep in mind that the output of the search results are identical to the regular blog list output and we are using the search without <a href="https://www.algolia.com/doc/guides/building-search-ui/going-further/conditional-display/react/#handling-the-empty-query">conditionally handling an empty query</a> - this means it will always display posts even if the user has not searched yet. Thus, we can actually replace the regular page output with the search results as in the updated source for <code>src/templates/blog.js</code> below:</p>
<pre><code>import React from &#39;react&#39;;
import _ from &#39;lodash&#39;;
import Search from &#39;../components/Search&#39;;

import { Layout } from &#39;../components/index&#39;;
import { getPages } from &#39;../utils&#39;;

export default class Blog extends React.Component {
  render() {
    let display_posts = _.orderBy(getPages(this.props.pageContext.pages, &#39;/posts&#39;), &#39;frontmatter.date&#39;, &#39;desc&#39;);
    return (
      &lt;Layout {...this.props}&gt;
        &lt;div className=&quot;outer&quot;&gt;
          &lt;div className=&quot;inner&quot;&gt;
            &lt;Search indexName=&quot;Posts&quot;&gt;&lt;/Search&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/Layout&gt;
    );
  }
}
</code></pre>
<p>Copy</p>
<p>The result works as shown below.</p>
<figure>
<img src="https://www.stackbit.com/docs/images/finished-search.gif" alt="finished search results" /><figcaption>finished search results</figcaption>
</figure>
<h2 id="deployment"><a href="https://www.stackbit.com/docs/developer-guides/gatsby/site-search/#deployment"></a>Deployment</h2>
<p>When we’re ready to deploy the search, we need to ensure that the environment variables we created are available when we deploy. On Netlify, all we need to do is go to Settings &gt; Build &amp; Deploy &gt; Environment and add the necessary variables defined in our <code>.env</code> file to our deployment settings.</p>
<figure>
<img src="https://www.stackbit.com/docs/images/env-variables-sm.png" alt="Netlify environment variables" /><figcaption>Netlify environment variables</figcaption>
</figure>
<p>We’re all set!</p>
</body>
</html>
