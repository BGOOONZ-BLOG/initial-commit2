<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Objects-In-JavaScript</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="objects-in-javascript">Objects In JavaScript</h1>
<p>The object is a data structure that stores other data, similar to how an array stores elements.</p>
<hr />
<h3 id="objects-in-javascript-1">Objects In JavaScript</h3>
<h4 id="the-object-is-a-data-structure-that-stores-other-data-similar-to-how-an-array-stores-elements.">The <code>object</code> is a data structure that stores other data, similar to how an array stores elements.</h4>
<figure>
<img src="https://cdn-images-1.medium.com/max/800/0*p8Mho_ONNupan--Z.png" class="graf-image" />
</figure>
<ul>
<li><span id="5c25">The object differs in that each <code>value</code> stores in an obj is associated with a <code>key</code>.</span></li>
</ul>
<h3 id="the-object"><strong>The Object</strong></h3>
<p>In other programming languages, objects are referred to as, "dictionaries”, "maps”, or "associative arrays”.</p>
<ul>
<li><span id="53af">Objects are indexed with <code>keys</code> instead of numbers.</span></li>
<li><span id="2cc0">Order is not guaranteed within an Object.</span></li>
<li><span id="ac45">Objects are defined by using curly braces <code>{}</code></span></li>
<li><span id="2ca3">You can think of Objects as tables.</span></li>
</ul>
<h4 id="setting-keys-and-values"><strong>Setting Keys and Values</strong></h4>
<ul>
<li><span id="d19c">We assign values to an object by defining the name of the key in brackets and assigning it to a value.</span></li>
</ul>
<!-- -->
<pre><code>&gt; car {
    color: &quot;Blue&quot;,
    seats: 2
}

&gt;
&quot;color&quot; in car;
true

    &gt;
    &quot;model&quot; in car;
false</code></pre>
<ul>
<li><span id="6499">If we try to access a key that has not yet been assigned within an object we will output undefined.</span></li>
<li><span id="7d01">The <strong>preferred method</strong> for checking to see if an object exists at a key is to use the <code>in</code> operator.</span></li>
</ul>
<h4 id="using-variables-as-keys"><strong>Using Variables as Keys</strong></h4>
<ul>
<li><span id="e833">It is useful to set a variable as a key because variables can be re-assigned new values — this way we can quickly access different data and also create new key/value pairs.</span></li>
</ul>
<h3 id="using-different-notations">Using Different Notations</h3>
<p><strong>Dot notation:</strong></p>
<ul>
<li><span id="bec1">Property identifies can only be alphanumeric (and <code>_</code> and <code>$</code>)</span></li>
<li><span id="d353">Property identifiers cannot start with a number.</span></li>
<li><span id="0c2b">Property identifiers cannot contain variables.</span></li>
<li><span id="b348">OK — <code>obj.prop_1</code>, <code>obj.prop$</code></span></li>
<li><span id="bebd">Not OK — <code>obj.1prop</code>, <code>obj.prop name</code></span></li>
</ul>
<p><strong>Bracket notation:</strong></p>
<ul>
<li><span id="1e9e">Property identifiers have to be a String or a variable that references a String.</span></li>
<li><span id="a2b7">It is okay to use variables, spaces, and Strings that start with numbers</span></li>
<li><span id="6893">OK — <code>obj["1prop"]</code>, <code>obj["prop name"]</code></span></li>
</ul>
<!-- -->
<pre><code>&gt;
let dog = {};
undefined

    &gt;
    dog.bark = &quot;Bowowowo&quot;;
&quot;Bowowowowo&quot;

&gt;
dog.bark &quot;Bowowowo&quot;

    &gt;
    dog {
        bark: &quot;Bowowowowo&quot;
    }</code></pre>
<ul>
<li><span id="ec54">We can also use <strong>dot notation</strong> <strong>".”</strong> to access key/value pairs in an object.</span></li>
<li><span id="cd22">One thing to note is that when using dot notation, we do not have to use string quotes as the key.</span></li>
</ul>
<h4 id="bracket-notation-vs-dot-notation"><strong>Bracket Notation vs Dot Notation</strong></h4>
<p><strong>DotBracket</strong>Easier To ReadYou can use variables as keys! Easier To Write b/c do not need Quotations. Okay to use variables and Strings that start with numbers.Cannot access with VariablesKeys cannot contain numbers as their first character</p>
<ul>
<li><span id="8f18"><strong>When accessing object keys</strong>: Bracket notation needs to refer to that key in quotations, dot notation doesn’t.</span></li>
<li><span id="83be"><strong>When accessing object keys via a variable</strong>: Bracket notation can refer to that key w/o use of quotations, dot notation can’t do this at all.</span></li>
</ul>
<!-- -->
<ul>
<li><span id="872f">As illustrated above, the dot notation cannot access a variable key — since it takes a <strong>literal</strong> interpretation of the key.</span></li>
</ul>
<p>You can put an object together in a single statement.</p>
<pre><code>let myDog = {
    name: &quot;Fido&quot;,
    type: &quot;Doge&quot;,
    age: 2,
    favoriteToys: [&quot;bone&quot;, &quot;ball&quot;],
};</code></pre>
<h4 id="operator-precedence-revisited"><strong>Operator Precedence Revisited</strong></h4>
<ul>
<li><span id="ffba">The concept of Operator Precedence also applies to objects.</span></li>
<li><span id="79e4">There are two types of associativity:</span></li>
<li><span id="1883"><code>Right Associativity</code> : When code is evaluated right to left.</span></li>
</ul>
<!-- -->
<pre><code>a = b = 1;

- Since **assignment of variables** takes lowest precedence, we end up evaluating b = 1 first before a = b.</code></pre>
<ul>
<li><span id="3d7c"><code>Left Associativity</code> : When code is evaluated left to right.</span></li>
</ul>
<!-- -->
<pre><code>let id = &quot;header&quot;;
    let element = document.getElementById(id).value;

- We first resolve the document variable, then use dot notation to retrieve the getElementById function, we eval it&#39;s arguments, access it&#39;s value, and then retrieve assignment \(the lowest precedence\).</code></pre>
<h3 id="iterating-through-objects">Iterating Through Objects</h3>
<p>Because objects store <strong>unordered</strong> key-value pairs, we do not rely on indices to access values; instead, we rely on our keys.</p>
<h4 id="a-new-kind-of-for-loop"><strong>A New Kind of For Loop</strong></h4>
<blockquote>
<p>SYNTAX: for (let variable in object) {statement};</p>
</blockquote>
<ul>
<li><span id="6607">We use a special syntax to iterate through each key of an object called a <code>for-in loop</code>.</span></li>
</ul>
<h4 id="methods-vs-functions"><strong>Methods vs Functions</strong></h4>
<p>A <code>Method</code> is a function that belongs to an object. Every method is a function, but not every function is a method.</p>
<pre><code>myFunc is a
function
myObject.myFunc is a method of the object myObject
myObject[&quot;myFunc&quot;] is a method of the object myObject</code></pre>
<ul>
<li><span id="417a"><strong>Methods</strong> are just a key-value pair where the <strong>key is the function name and the value is the function definition</strong>.</span></li>
</ul>
<!-- -->
<ul>
<li><span id="cf41">To invoke these methods we just need to specify which object is calling that method.</span></li>
</ul>
<!-- -->
<pre><code>myObject.methodName();</code></pre>
<h4 id="useful-object-methods"><strong>Useful Object Methods</strong></h4>
<ul>
<li><span id="dd4b"><code>Object.keys()</code> : A method that allows us to iterate through keys, it accepts an obj as the argument and returns an array of the keys.</span></li>
<li><span id="0d49"><code>Object.values()</code> : Method that accepts an object as the argument and returns an array of the values.</span></li>
</ul>
<h4 id="iterating-through-an-objects-keys-values"><strong>Iterating through an Object’s keys &amp; values</strong></h4>
<ul>
<li><span id="b2aa"><code>Object.entries</code> : Method that accepts an object as the argument and returns an array of the [key, value] pairs within.</span></li>
</ul>
<!-- -->
<pre><code>&gt; Object.entries(cat)[[&#39;name&#39;, &#39;Freyja&#39;], [&#39;color&#39;, &#39;orange&#39;]]</code></pre>
<h3 id="references-vs-primitives">References vs Primitives</h3>
<h4 id="primitives-vs-objects"><strong>Primitives vs Objects</strong></h4>
<p>So far we have learned about 6 different data types:</p>
<ul>
<li><span id="9e34"><strong>Primitive</strong>: Boolean, Null, Undefined, Number, String.</span></li>
<li><span id="a9e1"><strong>Reference</strong>: Object (Arrays are a type of object)</span></li>
<li><span id="4684">Remember that <strong>primitive</strong> types are immutable!</span></li>
</ul>
<h4 id="immutability"><strong>Immutability</strong></h4>
<ul>
<li><span id="7e6d">When we reassign primitives we simply have our variable point elsewhere in memory.</span></li>
<li><span id="701f">In a nutshell, <strong>immutability</strong> cannot change values in memory, but only reassign where our variables are pointing to.</span></li>
</ul>
<h4 id="mutability"><strong>Mutability</strong></h4>
<ul>
<li><span id="0930">If we change either cat1 or cat2, our computer memory will change because they are both pointing at the same memory location.</span></li>
</ul>
<h3 id="rest-and-spread">Rest and Spread</h3>
<h4 id="using-the-spread-operator-and-rest-parameter-syntax-accepting-arguments"><strong>Using the Spread Operator and Rest Parameter Syntax</strong> <strong>Accepting Arguments</strong></h4>
<ul>
<li><span id="f131">Just keep in mind that the function will still run even if it is not passed any arguments.</span></li>
<li><span id="ecdf">Parameters will take just as many arguments as they need even if more than enough is offered.</span></li>
<li><span id="ff36">We will encounter an error if there are not enough parameters ( &gt; 0).</span></li>
</ul>
<h4 id="utilizing-rest-parameters"><strong>Utilizing Rest Parameters</strong></h4>
<ul>
<li><span id="6379"><code>Rest Parameter Syntax</code> : Allows us to capture all of a function’s incoming arguments into an array.</span></li>
<li><span id="0807">Only the last parameter can be a rest parameter.</span></li>
</ul>
<h4 id="utilizing-spread-syntax"><strong>Utilizing Spread Syntax</strong></h4>
<ul>
<li><span id="71ff"><strong>Spread Operator</strong>: This allows us to break down a data type into the elements that make it up.</span></li>
<li><span id="6ef0">Takes a data type (i.e. array, obj) and spreads the values of that type where elements are expected.</span></li>
<li><span id="15e5">Takes iterable data and spreads the elements of that type where arguments are expected.</span></li>
</ul>
<!-- -->
<pre><code>let numArray = [1, 2, 3];

// here we are taking `numArray` and *spreading* it into a new array where
// comma separated elements are expected to be
let moreNums = [...numArray, 4, 5, 6];

&gt;
moreNums
// =&gt; [1, 2, 3, 4, 5, 6]</code></pre>
<p><strong>With Objects</strong></p>
<hr />
<h3 id="learn-more-on-my-blog">Learn More On My Blog:</h3>
<p><a href="https://bgoonz-blog.netlify.app/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://bgoonz-blog.netlify.app/"><strong>Web-Dev-Hub</strong> <br/></p>
<p><em>Memoization, Tabulation, and Sorting Algorithms by Example Why is looking at runtime not a reliable method of…</em>bgoonz-blog.netlify.app</a><a href="https://bgoonz-blog.netlify.app/" class="js-mixtapeImage mixtapeImage u-ignoreBlock"></a></p>
<p>By <a href="https://medium.com/@bryanguner" class="p-author h-card">Bryan Guner</a> on <a href="https://medium.com/p/b212486dade6">May 27, 2021</a>.</p>
<p><a href="https://medium.com/@bryanguner/objects-in-javascript-b212486dade6" class="p-canonical">Canonical link</a></p>
<p>August 31, 2021.</p>
</body>
</html>
