<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>assign</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="object.assign">Object.assign()</h1>
<p>The <code>Object.assign()</code> method copies all <a href="propertyisenumerable">enumerable</a> <a href="hasownproperty">own properties</a> from one or more <em>source objects</em> to a <em>target object</em>. It returns the target object.</p>
<h2 id="syntax">Syntax</h2>
<pre><code>Object.assign(target, ...sources)</code></pre>
<h3 id="parameters">Parameters</h3>
<p><code>target</code><br />
The target object — what to apply the sources’ properties to, which is returned after it is modified.</p>
<p><code>sources</code><br />
The source object(s) — objects containing the properties you want to apply.</p>
<h3 id="return-value">Return value</h3>
<p>The target object.</p>
<h2 id="description">Description</h2>
<p>Properties in the target object are overwritten by properties in the sources if they have the same <a href="keys">key</a>. Later sources’ properties overwrite earlier ones.</p>
<p>The <code>Object.assign()</code> method only copies <em>enumerable</em> and <em>own</em> properties from a source object to a target object. It uses <code>[[Get]]</code> on the source and <code>[[Set]]</code> on the target, so it will invoke <a href="../../functions/get">getters</a> and <a href="../../functions/set">setters</a>. Therefore it <em>assigns</em> properties, versus copying or defining new properties. This may make it unsuitable for merging new properties into a prototype if the merge sources contain getters.</p>
<p>For copying property definitions (including their enumerability) into prototypes, use <a href="getownpropertydescriptor"><code>Object.getOwnPropertyDescriptor()</code></a> and <a href="defineproperty"><code>Object.defineProperty()</code></a> instead.</p>
<p>Both <a href="../string"><code>String</code></a> and <a href="../symbol"><code>Symbol</code></a> properties are copied.</p>
<p>In case of an error, for example if a property is non-writable, a <a href="../typeerror"><code>TypeError</code></a> is raised, and the <code>target</code> object is changed if any properties are added before the error is raised.</p>
<p><strong>Note:</strong> <code>Object.assign()</code> does not throw on <a href="../null"><code>null</code></a> or <a href="../undefined"><code>undefined</code></a> sources.</p>
<h2 id="polyfill">Polyfill</h2>
<p>This <a href="https://developer.mozilla.org/en-US/docs/Glossary/Polyfill">polyfill</a> doesn’t support symbol properties, since ES5 doesn’t have symbols anyway:</p>
<pre><code>if (typeof Object.assign !== &#39;function&#39;) {
  // Must be writable: true, enumerable: false, configurable: true
  Object.defineProperty(Object, &quot;assign&quot;, {
    value: function assign(target, varArgs) { // .length of function is 2
      &#39;use strict&#39;;
      if (target === null || target === undefined) {
        throw new TypeError(&#39;Cannot convert undefined or null to object&#39;);
      }

      var to = Object(target);

      for (var index = 1; index &lt; arguments.length; index++) {
        var nextSource = arguments[index];

        if (nextSource !== null &amp;&amp; nextSource !== undefined) {
          for (var nextKey in nextSource) {
            // Avoid bugs when hasOwnProperty is shadowed
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    },
    writable: true,
    configurable: true
  });
}</code></pre>
<h2 id="examples">Examples</h2>
<h3 id="cloning-an-object">Cloning an object</h3>
<pre><code>const obj = { a: 1 };
const copy = Object.assign({}, obj);
console.log(copy); // { a: 1 }</code></pre>
<h3 id="warning-for-deep-clone">Warning for Deep Clone</h3>
<p>For deep cloning, we need to use alternatives, because <code>Object.assign()</code> copies property values.</p>
<p>If the source value is a reference to an object, it only copies the reference value.</p>
<pre><code>function test() {
  &#39;use strict&#39;;

  let obj1 = { a: 0 , b: { c: 0}};
  let obj2 = Object.assign({}, obj1);
  console.log(JSON.stringify(obj2)); // { &quot;a&quot;: 0, &quot;b&quot;: { &quot;c&quot;: 0}}

  obj1.a = 1;
  console.log(JSON.stringify(obj1)); // { &quot;a&quot;: 1, &quot;b&quot;: { &quot;c&quot;: 0}}
  console.log(JSON.stringify(obj2)); // { &quot;a&quot;: 0, &quot;b&quot;: { &quot;c&quot;: 0}}

  obj2.a = 2;
  console.log(JSON.stringify(obj1)); // { &quot;a&quot;: 1, &quot;b&quot;: { &quot;c&quot;: 0}}
  console.log(JSON.stringify(obj2)); // { &quot;a&quot;: 2, &quot;b&quot;: { &quot;c&quot;: 0}}

  obj2.b.c = 3;
  console.log(JSON.stringify(obj1)); // { &quot;a&quot;: 1, &quot;b&quot;: { &quot;c&quot;: 3}}
  console.log(JSON.stringify(obj2)); // { &quot;a&quot;: 2, &quot;b&quot;: { &quot;c&quot;: 3}}

  // Deep Clone
  obj1 = { a: 0 , b: { c: 0}};
  let obj3 = JSON.parse(JSON.stringify(obj1));
  obj1.a = 4;
  obj1.b.c = 4;
  console.log(JSON.stringify(obj3)); // { &quot;a&quot;: 0, &quot;b&quot;: { &quot;c&quot;: 0}}
}

test();</code></pre>
<h3 id="merging-objects">Merging objects</h3>
<pre><code>const o1 = { a: 1 };
const o2 = { b: 2 };
const o3 = { c: 3 };

const obj = Object.assign(o1, o2, o3);
console.log(obj); // { a: 1, b: 2, c: 3 }
console.log(o1);  // { a: 1, b: 2, c: 3 }, target object itself is changed.</code></pre>
<h3 id="merging-objects-with-same-properties">Merging objects with same properties</h3>
<pre><code>const o1 = { a: 1, b: 1, c: 1 };
const o2 = { b: 2, c: 2 };
const o3 = { c: 3 };

const obj = Object.assign({}, o1, o2, o3);
console.log(obj); // { a: 1, b: 2, c: 3 }</code></pre>
<p>The properties are overwritten by other objects that have the same properties later in the parameters order.</p>
<h3 id="copying-symbol-typed-properties">Copying symbol-typed properties</h3>
<pre><code>const o1 = { a: 1 };
const o2 = { [Symbol(&#39;foo&#39;)]: 2 };

const obj = Object.assign({}, o1, o2);
console.log(obj); // { a : 1, [Symbol(&quot;foo&quot;)]: 2 } (cf. bug 1207182 on Firefox)
Object.getOwnPropertySymbols(obj); // [Symbol(foo)]</code></pre>
<h3 id="properties-on-the-prototype-chain-and-non-enumerable-properties-cannot-be-copied">Properties on the prototype chain and non-enumerable properties cannot be copied</h3>
<pre><code>const obj = Object.create({ foo: 1 }, { // foo is on obj&#39;s prototype chain.
  bar: {
    value: 2  // bar is a non-enumerable property.
  },
  baz: {
    value: 3,
    enumerable: true  // baz is an own enumerable property.
  }
});

const copy = Object.assign({}, obj);
console.log(copy); // { baz: 3 }</code></pre>
<h3 id="primitives-will-be-wrapped-to-objects">Primitives will be wrapped to objects</h3>
<pre><code>const v1 = &#39;abc&#39;;
const v2 = true;
const v3 = 10;
const v4 = Symbol(&#39;foo&#39;);

const obj = Object.assign({}, v1, null, v2, undefined, v3, v4);
// Primitives will be wrapped, null and undefined will be ignored.
// Note, only string wrappers can have own enumerable properties.
console.log(obj); // { &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; }</code></pre>
<h3 id="exceptions-will-interrupt-the-ongoing-copying-task">Exceptions will interrupt the ongoing copying task</h3>
<pre><code>const target = Object.defineProperty({}, &#39;foo&#39;, {
  value: 1,
  writable: false
}); // target.foo is a read-only property

Object.assign(target, { bar: 2 }, { foo2: 3, foo: 3, foo3: 3 }, { baz: 4 });
// TypeError: &quot;foo&quot; is read-only
// The Exception is thrown when assigning target.foo

console.log(target.bar);  // 2, the first source was copied successfully.
console.log(target.foo2); // 3, the first property of the second source was copied successfully.
console.log(target.foo);  // 1, exception is thrown here.
console.log(target.foo3); // undefined, assign method has finished, foo3 will not be copied.
console.log(target.baz);  // undefined, the third source will not be copied either.</code></pre>
<h3 id="copying-accessors">Copying accessors</h3>
<pre><code>const obj = {
  foo: 1,
  get bar() {
    return 2;
  }
};

let copy = Object.assign({}, obj);
console.log(copy);
// { foo: 1, bar: 2 }
// The value of copy.bar is obj.bar&#39;s getter&#39;s return value.

// This is an assign function that copies full descriptors
function completeAssign(target, ...sources) {
  sources.forEach(source =&gt; {
    let descriptors = Object.keys(source).reduce((descriptors, key) =&gt; {
      descriptors[key] = Object.getOwnPropertyDescriptor(source, key);
      return descriptors;
    }, {});

    // By default, Object.assign copies enumerable Symbols, too
    Object.getOwnPropertySymbols(source).forEach(sym =&gt; {
      let descriptor = Object.getOwnPropertyDescriptor(source, sym);
      if (descriptor.enumerable) {
        descriptors[sym] = descriptor;
      }
    });
    Object.defineProperties(target, descriptors);
  });
  return target;
}

copy = completeAssign({}, obj);
console.log(copy);
// { foo:1, get bar() { return 2 } }</code></pre>
<h2 id="specifications">Specifications</h2>
<table>
<thead>
<tr class="header">
<th>
Specification
</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>
<p><a href="https://tc39.es/ecma262/#sec-object.assign">ECMAScript Language Specification (ECMAScript) <br/></p>
<span class="small">#sec-object.assign</span></a>
</td>
</tr>
</tbody>
</table>
<p><code>assign</code></p>
<p>45</p>
<p>12</p>
<p>34</p>
<p>No</p>
<p>32</p>
<p>9</p>
<p>45</p>
<p>45</p>
<p>34</p>
<p>32</p>
<p>9</p>
<p>5.0</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="defineproperties"><code>Object.defineProperties()</code></a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">Enumerability and ownership of properties</a></li>
<li><a href="../../operators/spread_syntax#spread_in_object_literals">Spread in object literals</a></li>
</ul>
<p>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br />
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign</a></p>
</body>
</html>
