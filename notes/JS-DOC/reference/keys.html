<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>keys</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="object.keys">Object.keys()</h1>
<p>The <code>Object.keys()</code> method returns an array of a given object’s own enumerable property <strong>names</strong>, iterated in the same order that a normal loop would.</p>
<h2 id="syntax">Syntax</h2>
<pre><code>Object.keys(obj)</code></pre>
<h3 id="parameters">Parameters</h3>
<p><code>obj</code><br />
The object of which the enumerable’s own properties are to be returned.</p>
<h3 id="return-value">Return value</h3>
<p>An array of strings that represent all the enumerable properties of the given object.</p>
<h2 id="description">Description</h2>
<p><code>Object.keys()</code> returns an array whose elements are strings corresponding to the enumerable properties found directly upon <code>object</code>. The ordering of the properties is the same as that given by looping over the properties of the object manually.</p>
<h2 id="examples">Examples</h2>
<h3 id="using-object.keys">Using Object.keys</h3>
<pre><code>// simple array
const arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
console.log(Object.keys(arr)); // console: [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;]

// array-like object
const obj = { 0: &#39;a&#39;, 1: &#39;b&#39;, 2: &#39;c&#39; };
console.log(Object.keys(obj)); // console: [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;]

// array-like object with random key ordering
const anObj = { 100: &#39;a&#39;, 2: &#39;b&#39;, 7: &#39;c&#39; };
console.log(Object.keys(anObj)); // console: [&#39;2&#39;, &#39;7&#39;, &#39;100&#39;]

// getFoo is a property which isn&#39;t enumerable
const myObj = Object.create({}, {
  getFoo: {
    value: function () { return this.foo; }
  }
});
myObj.foo = 1;
console.log(Object.keys(myObj)); // console: [&#39;foo&#39;]</code></pre>
<p>If you want <em>all</em> properties—including non-enumerables—see <a href="getownpropertynames"><code>Object.getOwnPropertyNames()</code></a>.</p>
<h3 id="non-object-coercion">Non-object coercion</h3>
<p>In ES5, if the argument to this method is not an object (a primitive), then it will cause a <a href="../typeerror"><code>TypeError</code></a>.</p>
<p>From ES2015 onwards, a non-object argument will be coerced to an object.</p>
<pre><code>// In ES5
Object.keys(&#39;foo&#39;);  // TypeError: &quot;foo&quot; is not an object

// In ES2015+
Object.keys(&#39;foo&#39;);  // [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</code></pre>
<h2 id="polyfill">Polyfill</h2>
<p>To add compatible <code>Object.keys</code> support in older environments that do not natively support it, copy the following snippet:</p>
<pre><code>// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
if (!Object.keys) {
  Object.keys = (function() {
    &#39;use strict&#39;;
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        hasDontEnumBug = !({ toString: null }).propertyIsEnumerable(&#39;toString&#39;),
        dontEnums = [
          &#39;toString&#39;,
          &#39;toLocaleString&#39;,
          &#39;valueOf&#39;,
          &#39;hasOwnProperty&#39;,
          &#39;isPrototypeOf&#39;,
          &#39;propertyIsEnumerable&#39;,
          &#39;constructor&#39;
        ],
        dontEnumsLength = dontEnums.length;

    return function(obj) {
      if (typeof obj !== &#39;function&#39; &amp;&amp; (typeof obj !== &#39;object&#39; || obj === null)) {
        throw new TypeError(&#39;Object.keys called on non-object&#39;);
      }

      var result = [], prop, i;

      for (prop in obj) {
        if (hasOwnProperty.call(obj, prop)) {
          result.push(prop);
        }
      }

      if (hasDontEnumBug) {
        for (i = 0; i &lt; dontEnumsLength; i++) {
          if (hasOwnProperty.call(obj, dontEnums[i])) {
            result.push(dontEnums[i]);
          }
        }
      }
      return result;
    };
  }());
}</code></pre>
<p>Please note that the above code includes non-enumerable keys in IE7 (and maybe IE8), when passing in an object from a different window.</p>
<p>For a simple Browser Polyfill, see <a href="https://tokenposts.blogspot.com.au/2012/04/javascript-objectkeys-browser.html">Javascript - Object.keys Browser Compatibility</a>.</p>
<h2 id="specifications">Specifications</h2>
<table>
<thead>
<tr class="header">
<th>
Specification
</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>
<p><a href="https://tc39.es/ecma262/#sec-object.keys">ECMAScript Language Specification (ECMAScript) <br/></p>
<span class="small">#sec-object.keys</span></a>
</td>
</tr>
</tbody>
</table>
<p><code>keys</code></p>
<p>5</p>
<p>12</p>
<p>4</p>
<p>9</p>
<p>12</p>
<p>5</p>
<p>1</p>
<p>18</p>
<p>4</p>
<p>12</p>
<p>5</p>
<p>1.0</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">Enumerability and ownership of properties</a></li>
<li><a href="propertyisenumerable"><code>Object.prototype.propertyIsEnumerable()</code></a></li>
<li><a href="create"><code>Object.create()</code></a></li>
<li><a href="getownpropertynames"><code>Object.getOwnPropertyNames()</code></a></li>
<li><a href="values"><code>Object.values()</code></a></li>
<li><a href="entries"><code>Object.entries()</code></a></li>
</ul>
<p>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br />
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys</a></p>
</body>
</html>
