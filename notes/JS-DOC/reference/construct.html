<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>construct</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="reflect.construct">Reflect.construct()</h1>
<p>The static <code>Reflect.construct()</code> method acts like the <a href="../../operators/new"><code>new</code></a> operator, but as a function. It is equivalent to calling <code>new target(...args)</code>. It gives also the added option to specify a different prototype.</p>
<h2 id="syntax">Syntax</h2>
<pre><code>Reflect.construct(target, argumentsList)
Reflect.construct(target, argumentsList, newTarget)</code></pre>
<h3 id="parameters">Parameters</h3>
<p><code>target</code><br />
The target function to call.</p>
<p><code>argumentsList</code><br />
An array-like object specifying the arguments with which <code>target</code> should be called.</p>
<p><code>newTarget</code> <span class="badge inline optional">Optional</span><br />
The constructor whose prototype should be used. See also the <a href="../../operators/new.target"><code>new.target</code></a> operator. If <code>newTarget</code> is not present, its value defaults to <code>target</code>.</p>
<h3 id="return-value">Return value</h3>
<p>A new instance of <code>target</code> (or <code>newTarget</code>, if present), initialized by <code>target</code> as a constructor with the given <code>argumentsList</code>.</p>
<h3 id="exceptions">Exceptions</h3>
<p>A <a href="../typeerror"><code>TypeError</code></a>, if <code>target</code> or <code>newTarget</code> are not constructors.</p>
<h2 id="description">Description</h2>
<p><code>Reflect.construct()</code> allows you to invoke a constructor with a variable number of arguments. (This would also be possible by using the <a href="../../operators/spread_syntax">spread syntax</a> combined with the <a href="../../operators/new"><code>new</code> operator</a>.)</p>
<pre><code>let obj = new Foo(...args)
let obj = Reflect.construct(Foo, args)</code></pre>
<h3 id="reflect.construct-vs-object.create"><code>Reflect.construct()</code> vs <code>Object.create()</code></h3>
<p>Prior to the introduction of <code>Reflect</code>, objects could be constructed using an arbitrary combination of constructor and prototype by using <a href="../object/create"><code>Object.create()</code></a>.</p>
<pre><code>function OneClass() {
    this.name = &#39;one&#39;
}

function OtherClass() {
    this.name = &#39;other&#39;
}

// Calling this:
let obj1 = Reflect.construct(OneClass, args, OtherClass)

// ...has the same result as this:
let obj2 = Object.create(OtherClass.prototype)
OneClass.apply(obj2, args)

console.log(obj1.name)  // &#39;one&#39;
console.log(obj2.name)  // &#39;one&#39;

console.log(obj1 instanceof OneClass)  // false
console.log(obj2 instanceof OneClass)  // false

console.log(obj1 instanceof OtherClass)  // true
console.log(obj2 instanceof OtherClass)  // true

//Another example to demonstrate below:

function func1(a, b, c, d) {
  console.log(arguments[3]);
}

function func2(d, e, f, g) {
  console.log(arguments[3]);
}

let obj1 = Reflect.construct(func1, [&#39;I&#39;, &#39;Love&#39;, &#39;my&#39;, &#39;India&#39;])
obj1</code></pre>
<p>However, while the end result is the same, there is one important difference in the process. When using <code>Object.create()</code> and <a href="../function/apply"><code>Function.prototype.apply()</code></a>, the <code>new.target</code> operator will point to <code>undefined</code> within the function used as the constructor, since the <code>new</code> keyword is not being used to create the object.</p>
<p>When invoking <code>Reflect.construct()</code>, on the other hand, the <code>new.target</code> operator will point to the <code>newTarget</code> parameter if supplied, or <code>target</code> if not.</p>
<pre><code>function OneClass() {
    console.log(&#39;OneClass&#39;)
    console.log(new.target)
}
function OtherClass() {
    console.log(&#39;OtherClass&#39;)
    console.log(new.target)
}

let obj1 = Reflect.construct(OneClass, args)
// Output:
//     OneClass
//     function OneClass { ... }

let obj2 = Reflect.construct(OneClass, args, OtherClass)
// Output:
//     OneClass
//     function OtherClass { ... }

let obj3 = Object.create(OtherClass.prototype);
OneClass.apply(obj3, args)
// Output:
//     OneClass
//     undefined</code></pre>
<h2 id="examples">Examples</h2>
<h3 id="using-reflect.construct">Using <code>Reflect.construct()</code></h3>
<pre><code>let d = Reflect.construct(Date, [1776, 6, 4])
d instanceof Date  // true
d.getFullYear()    // 1776</code></pre>
<h2 id="specifications">Specifications</h2>
<table>
<thead>
<tr class="header">
<th>
Specification
</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>
<p><a href="https://tc39.es/ecma262/#sec-reflect.construct">ECMAScript Language Specification (ECMAScript) <br/></p>
<span class="small">#sec-reflect.construct</span></a>
</td>
</tr>
</tbody>
</table>
<p><code>construct</code></p>
<p>49</p>
<p>12</p>
<p>42</p>
<p>No</p>
<p>36</p>
<p>10</p>
<p>49</p>
<p>49</p>
<p>42</p>
<p>36</p>
<p>10</p>
<p>5.0</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="../reflect"><code>Reflect</code></a></li>
<li><a href="../../operators/new"><code>new</code></a></li>
<li><code>new.target</code></li>
</ul>
<p>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br />
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/construct" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/construct</a></p>
</body>
</html>
